# Домашнее задание №3

## Код оформлен в виде Rust-библиотеки с тест-примерами
Для запуска примеров с помощью cargo даны соответствующие команды терминала в тематических разделах ниже.
Сводные таблицы находятся по ссылке https://docs.google.com/spreadsheets/d/1h8YcuXKBIISbauGNEm0TITSM0xe0QklUhx-DUnxiAxE

## Возведение в степень
Для запуска тестовых примеров использовать команду cargo run --example test_pow --release

Ни в одном случае не удалось получить текстовое представление, совпадающее с тестовым. Однако во всех случаях ответы правильные.
Алгоритм с разложением показателя степени в двоичное число оказался настолько эффективен, что в предложенных тестах справляется с задачей in no time.
Благодаря этому алгоритму матричный алгоритм побеждает в поиске чисел Фибоначчи.

## Поиск чисел Фибоначчи
Для запуска тестовых примеров использовать команду cargo run --example test_fibo --release

Рекурсивные алгоритмы проваливают на больших числах, как по времени исполнения, так и по переполнению стека.
Итеративный алгоритм с трудом выдерживает поиск число номер 10_000_000.
Матричный алгоритм выигрывает, опираясь на быстрый алгоритм возведения в степень.

## Поиск простых чисел
Для запуска тестовых примеров использовать команду cargo run --example test_primes --release

Поиск делителей оказывается не эффективен при больших числах в пределах 64-битных целых.
Время исполнения сильно страдает при повышении нагрузки на оперативную память. 
По этой причине оптимизированное по памяти решето обыгрывает стандартный массив bool.
А более эффективный алгоритм O(N) фактически зависает. 120 секунд были получены при повышении приритета процесса счета в операционной системе. Монитор системы показывал захват всей оперативной памяти (7 ГБ).
